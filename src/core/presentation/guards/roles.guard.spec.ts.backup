import { ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Test, TestingModule } from '@nestjs/testing';
import { RolesGuard } from './roles.guard';
import { ROLES_KEY } from '../decorators/roles.decorator';
import { Role } from '../../../modules/roles/domain/enums/role.enum';
import {
  IUserRepository,
  USER_REPOSITORY,
} from '../../../modules/users/domain/repositories/user.repository.interface';

describe('RolesGuard', () => {
  let guard: RolesGuard;
  let reflector: jest.Mocked<Reflector>;
  let userRepository: jest.Mocked<IUserRepository>;
  let mockExecutionContext: jest.Mocked<ExecutionContext>;
  let mockGetRequest: jest.Mock;

  interface MockUser {
    id: string;
    [key: string]: unknown;
  }

  const createMockContext = (
    user?: MockUser | null,
    headers?: Record<string, string>,
  ) => {
    mockGetRequest.mockReturnValue({
      user,
      headers: headers || {},
    });
    return mockExecutionContext;
  };

  beforeEach(async () => {
    reflector = {
      getAllAndOverride: jest.fn(),
    } as jest.Mocked<Reflector>;

    userRepository = {
      getRolesByOrganization: jest.fn(),
      findById: jest.fn(),
      findByEmail: jest.fn(),
      findBySupabaseUserId: jest.fn(),
      existsByEmail: jest.fn(),
      findAll: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      softDelete: jest.fn(),
    } as jest.Mocked<IUserRepository>;

    mockGetRequest = jest.fn();
    mockExecutionContext = {
      getHandler: jest.fn(),
      getClass: jest.fn(),
      switchToHttp: jest.fn().mockReturnValue({
        getRequest: mockGetRequest,
      }),
      switchToRpc: jest.fn(),
      switchToWs: jest.fn(),
      getType: jest.fn(),
      getArgs: jest.fn(),
      getArgByIndex: jest.fn(),
    } as jest.Mocked<ExecutionContext>;

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        RolesGuard,
        { provide: Reflector, useValue: reflector },
        { provide: USER_REPOSITORY, useValue: userRepository },
      ],
    }).compile();

    guard = module.get<RolesGuard>(RolesGuard);
  });

  it('should be defined', () => {
    expect(guard).toBeDefined();
  });

  describe('canActivate', () => {
    describe('when no roles required', () => {
      it('should allow access when roles are undefined', async () => {
        const getAllAndOverrideSpy = jest.spyOn(reflector, 'getAllAndOverride');
        getAllAndOverrideSpy.mockReturnValue(undefined);
        createMockContext({ id: 'user-123' });

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(true);
        expect(getAllAndOverrideSpy).toHaveBeenCalled();
      });

      it('should allow access when roles array is empty', async () => {
        const getAllAndOverrideSpy = jest.spyOn(reflector, 'getAllAndOverride');
        getAllAndOverrideSpy.mockReturnValue([]);
        createMockContext({ id: 'user-123' });

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(true);
        expect(getAllAndOverrideSpy).toHaveBeenCalled();
      });
    });

    describe('when user is not authenticated', () => {
      it('should deny access when user is undefined', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.ADMIN]);
        createMockContext(undefined);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(false);
      });

      it('should deny access when user is null', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.ADMIN]);
        createMockContext(null);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(false);
      });
    });

    describe('SUPER_ADMIN behavior', () => {
      it('should allow SUPER_ADMIN access without organization ID', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.ADMIN]);
        createMockContext({ id: 'user-123' }, {});
        const rbofn = userRepository.getRolesByOrganization; rbofn.mockResolvedValue([
          Role.SUPER_ADMIN,
        ]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(true);
        const getRolesByOrgSpy = jest.mocked(
          const rbofn = userRepository.getRolesByOrganization; rbofn,
        );
        expect(getRolesByOrgSpy).toHaveBeenCalledWith('user-123', undefined);
      });

      it('should allow SUPER_ADMIN access to any route requiring any role', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.ADMIN]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        const rbofn = userRepository.getRolesByOrganization; rbofn.mockResolvedValue([
          Role.SUPER_ADMIN,
        ]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(true);
      });
    });

    describe('organization context required', () => {
      it('should deny access for non-SUPER_ADMIN without organization ID', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.ADMIN]);
        createMockContext({ id: 'user-123' }, {});
        userRepository.getRolesByOrganization.mockResolvedValue([Role.ADMIN]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(false);
      });

      it('should allow access when user has required role in organization', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.ADMIN]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        userRepository.getRolesByOrganization.mockResolvedValue([Role.ADMIN]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(true);
        const getRolesByOrgSpy = jest.mocked(
          const rbofn = userRepository.getRolesByOrganization; rbofn,
        );
        expect(getRolesByOrgSpy).toHaveBeenCalledWith('user-123', 'org-123');
      });

      it('should pass organization ID to repository', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.COLABORADOR]);
        createMockContext(
          { id: 'user-456' },
          { 'x-organization-id': 'org-789' },
        );
        const rbofn = userRepository.getRolesByOrganization; rbofn.mockResolvedValue([
          Role.COLABORADOR,
        ]);

        await guard.canActivate(mockExecutionContext);

        const getRolesByOrgSpy = jest.mocked(
          const rbofn = userRepository.getRolesByOrganization; rbofn,
        );
        expect(getRolesByOrgSpy).toHaveBeenCalledWith('user-456', 'org-789');
      });
    });

    describe('role hierarchy', () => {
      it('should allow access when user has higher role (lower hierarchy number)', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.COLABORADOR]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        userRepository.getRolesByOrganization.mockResolvedValue([Role.ADMIN]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(true);
      });

      it('should allow access when user has equal role to required', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.GESTOR]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        userRepository.getRolesByOrganization.mockResolvedValue([Role.GESTOR]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(true);
      });

      it('should deny access when user has lower role (higher hierarchy number)', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.ADMIN]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        const rbofn = userRepository.getRolesByOrganization; rbofn.mockResolvedValue([
          Role.COLABORADOR,
        ]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(false);
      });

      it('should allow SUPER_ADMIN to access ADMIN routes', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.ADMIN]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        const rbofn = userRepository.getRolesByOrganization; rbofn.mockResolvedValue([
          Role.SUPER_ADMIN,
        ]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(true);
      });

      it('should deny COLABORADOR access to GESTOR routes', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.GESTOR]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        const rbofn = userRepository.getRolesByOrganization; rbofn.mockResolvedValue([
          Role.COLABORADOR,
        ]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(false);
      });
    });

    describe('multiple required roles', () => {
      it('should allow access if user has any one of multiple required roles', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.ADMIN, Role.GESTOR]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        userRepository.getRolesByOrganization.mockResolvedValue([Role.GESTOR]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(true);
        const getRolesByOrgSpy = jest.mocked(
          const rbofn = userRepository.getRolesByOrganization; rbofn,
        );
        expect(getRolesByOrgSpy).toHaveBeenCalledWith('user-123', 'org-123');
      });

      it('should allow access if user has higher role than any required', async () => {
        const gaofn = reflector.getAllAndOverride; gaofn.mockReturnValue([
          Role.GESTOR,
          Role.COLABORADOR,
        ]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        userRepository.getRolesByOrganization.mockResolvedValue([Role.ADMIN]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(true);
        const getRolesByOrgSpy = jest.mocked(
          const rbofn = userRepository.getRolesByOrganization; rbofn,
        );
        expect(getRolesByOrgSpy).toHaveBeenCalledWith('user-123', 'org-123');
      });

      it('should deny access if user has lower role than all required', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.ADMIN, Role.GESTOR]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        const rbofn = userRepository.getRolesByOrganization; rbofn.mockResolvedValue([
          Role.COLABORADOR,
        ]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(false);
        const getRolesByOrgSpy = jest.mocked(
          const rbofn = userRepository.getRolesByOrganization; rbofn,
        );
        expect(getRolesByOrgSpy).toHaveBeenCalledWith('user-123', 'org-123');
      });
    });

    describe('multiple user roles', () => {
      it('should check all user roles against requirements', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.ADMIN]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        const rbofn = userRepository.getRolesByOrganization; rbofn.mockResolvedValue([
          Role.COLABORADOR,
          Role.GESTOR,
          Role.ADMIN,
        ]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(true);
        const getRolesByOrgSpy = jest.mocked(
          const rbofn = userRepository.getRolesByOrganization; rbofn,
        );
        expect(getRolesByOrgSpy).toHaveBeenCalledWith('user-123', 'org-123');
      });

      it('should use highest user role (lowest hierarchy number) for access', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.GESTOR]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        const rbofn = userRepository.getRolesByOrganization; rbofn.mockResolvedValue([
          Role.COLABORADOR,
          Role.ADMIN, // This should grant access (hierarchy 100 < 200)
        ]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(true);
        const getRolesByOrgSpy = jest.mocked(
          const rbofn = userRepository.getRolesByOrganization; rbofn,
        );
        expect(getRolesByOrgSpy).toHaveBeenCalledWith('user-123', 'org-123');
      });
    });

    describe('edge cases', () => {
      it('should handle empty user roles array', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.COLABORADOR]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        userRepository.getRolesByOrganization.mockResolvedValue([]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(false);
        const getRolesByOrgSpy = jest.mocked(
          const rbofn = userRepository.getRolesByOrganization; rbofn,
        );
        expect(getRolesByOrgSpy).toHaveBeenCalledWith('user-123', 'org-123');
      });

      it('should handle user not in organization', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.COLABORADOR]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        userRepository.getRolesByOrganization.mockResolvedValue([]);

        const result = await guard.canActivate(mockExecutionContext);

        expect(result).toBe(false);
        const getRolesByOrgSpy = jest.mocked(
          const rbofn = userRepository.getRolesByOrganization; rbofn,
        );
        expect(getRolesByOrgSpy).toHaveBeenCalledWith('user-123', 'org-123');
      });

      it('should correctly use reflector to get roles metadata', async () => {
        reflector.getAllAndOverride.mockReturnValue([Role.ADMIN]);
        createMockContext(
          { id: 'user-123' },
          { 'x-organization-id': 'org-123' },
        );
        userRepository.getRolesByOrganization.mockResolvedValue([Role.ADMIN]);

        await guard.canActivate(mockExecutionContext);

        const getAllAndOverrideFn = reflector.getAllAndOverride;
        expect(jest.mocked(getAllAndOverrideFn)).toHaveBeenCalledWith(
          ROLES_KEY,
          [mockExecutionContext.getHandler(), mockExecutionContext.getClass()],
        );
        const getRolesByOrgSpy = jest.mocked(
          const rbofn = userRepository.getRolesByOrganization; rbofn,
        );
        expect(getRolesByOrgSpy).toHaveBeenCalledWith('user-123', 'org-123');
      });
    });
  });
});
